=============MVC (module, view, controller) architecture in a nutshell=============
 
 Module layer: application's data and business logic
    
 Controller layer: application's request, interact with modules and send back responses

 View layer: only necessary if we have a grafical interface, in other words, a server-side rendered website. It's basically the template shown

Application logic: 
 -Code focused on the app's implementation, which makes it work
 -Concerned about managing requests and responses
 -A bridge for module-view layers

Business logic:
 -Code that is focused on solving business problem we set out to solve
 -Focused on the business needs itself.

Fat models/thin controllers philosofy: Put all logic in the models and keep controllers as simple as possible

============= async await =============

const variable = async (parameters) => {
    try {
        const variable = await function
    } catch (err) {
        error handling
    }
}

============= FILTERING QUERY =============

const Tour = mongoose.model("Tour", tourSchema);

// is the function made to access the tour collection in mongoDB

============= =============

Tour.find();

// is the method that finds the data in the collection (without parameters)

============= =============

Tour.find(req.query);

// is the easiest filtering, getting the data that matches the parameters in the query, like "?difficulty=easy&duration=5", but the problem is that other parameters might be in the query, like "sort" or "page" or "limit", for example, and we don't want those.

============= =============

const queryObj = {...req.query}
Tour.find(queryObj);

// the "{...req.query}" is a way of creating a hard copy of the query without interacting with it actually

============= =============

const excludedFields = ['any fields that you wanna exclude from the filtering']
excludedFields.forEach(el => delete queryObj[el]);

// const excludedFields = [] --- specifies what fields must be excluded from the query

// excludedFields.forEach(...) --- deletes all the elements in excludedFields (the array created) from the queryObj (a copy from the original query). This way we filter without changing the original query.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

API STUFF

BUILDING THE QUERY
// 1) FILTERING

    const queryObj = {...req.query} //take the field out of the object and create a new object, so we don't manipulate the original 
    const excludedFields = ['page', 'sort', 'limit', 'fields'];
    excludedFields.forEach(el => delete queryObj[el]); // forEach doesn't save a new array

// 2) ADVANCED FILTERING

    let queryStr = JSON.stringify(queryObj);
    queryStr = queryStr.replace(/\b(gte|gt|lte|lt)\b/g, match => `$${match}`);

    let query = Tour.find(JSON.parse(queryStr)); //finds queried data in the collection (in the easiest way)

// 3) SORTING

    if(req.query.sort) {
      const srotBy = req.query.sort.split(',').join(' ');
      query = query.sort(srotBy);
    } else {
      query = query.sort('-_id');
    }

// 4/ FIELD LIMITING

    if(req.query.fields) {
      const fields = req.query.fields.split(',').join(' ');
      query = query.select(fields);
    } else {
      query = query.select('-__v')
    }

// 5) paginate

    const page = req.query.page * 1 || 1;
    const limit = req.query.limit * 1 || 100;
    const skip = (page -1) * limit;

    query = query.skip(skip).limit(limit);

    if (req.query.page) {
      const numTours = await Tour.countDocuments();
      if (skip>=numTours) throw new Error('This page does not exist!');
    }

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!**************************************************!

//  this checkID middleware is no longer needed, it was just for studying purposes
.
exports.checkID = (req, res, next, val) => {
  console.log(`Tour ID is: ${val}`);
  if (!req.params.id * 1 > toursData.length) {
    return res.status(404).json({
      status: "fail",
      message: "id not found",
    });
  }
  next();
};

exports.checkBody = (req, res, next) => {
  if (!req.body.name || !req.body.price) {
    return res.status(400).json({
      status: "fail",
      message: "Missing name or price",
    });
  }
  next();
};


!************************************************!

================ DEBUGGING NODE.JS ===================

======================================================

================= ASYNC AWAIT ERRORHANDLING ===============
// THIS WAY IS NOT THE BEST, 'CAUSE YOU NEED TO HANDLE THE ERROR INSIDE THE ASYNC FUNCTION, AND DOING IT EACH TIME MAKES IT BAD-LOOKING
exports.createTour = async (req, res, next) => {
  try {
    const newTour = await Tour.create(req.body); // create a new instance in my collection
    //for now, the req.body is set up on postman
    res.status(201).json({
      status: "success",
      data: {
        tour: newTour,
      },
    });
  } catch (err) {
    res.status(400).json({
      status: "fail",
      message: err
    });
  }
};

//THIS IS THE BEST WAY, CREATE A FUNCTION TO CATCH THOSE ERRORS AND ENCAPSULATE THE FUNCTION IN IT
//the best part is that I can use it in every async function
module.exports = fn => {
  return (req, res, next) => {
    fn(req, res, next).catch(next);
  };
};

exports.createTour = catchAsync(async (req, res, next) => {
    const newTour = await Tour.create(req.body); // create a new instance in my collection
    //for now, the req.body is set up on postman
    res.status(201).json({
      status: "success",
      data: {
        tour: newTour,
      },
    })
});